generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AdminRole {
  ADMIN
}

enum VpnProtocol {
  VLESS
}

enum VpnTransport {
  WS
  TCP
}

enum VpnSecurity {
  NONE
  TLS
  REALITY
}

enum VpnUserStatus {
  ACTIVE
  BLOCKED
  EXPIRED
  NEW
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  CANCELED
  CHARGEBACK
}

enum PaymentIntentStatus {
  PENDING
  PAID
  CANCELED
  EXPIRED
  CHARGEBACK
}

enum PaymentProvider {
  TELEGRAM_STARS
  PLATEGA
  CRYPTOCLOUD
}

enum SupportMessageType {
  USER_MESSAGE
  ADMIN_REPLY
}

enum SupportTicketStatus {
  OPEN
  CLOSED
}

enum BrowserLoginStatus {
  PENDING
  APPROVED
  EXPIRED
}

model AdminUser {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  role         AdminRole @default(ADMIN)
  createdAt    DateTime @default(now())

  @@map("admin_users")
}

model VpnServer {
  id               String      @id @default(cuid())
  name             String
  host             String
  port             Int
  protocol         VpnProtocol @default(VLESS)
  transport        VpnTransport
  tls              Boolean     @default(true)
  path             String?
  publicKey        String
  shortId          String
  maxUsers         Int         @default(0)
  active           Boolean     @default(true)
  createdAt        DateTime    @default(now())

  // panel integration
  panelBaseUrl     String?
  panelInboundId   Int?
  panelPasswordEnc String?
  panelUsername    String?
  security         VpnSecurity @default(NONE)
  sni              String?

  // Xray Stats API (gRPC): если заданы — трафик берётся через GetStats вместо панели
  xrayStatsHost    String?
  xrayStatsPort    Int?

  // UI
  isRecommended    Boolean     @default(false)

  // relations
  users            VpnUser[]
  userServers      UserServer[]

  @@map("vpn_servers")
}

model VpnUser {
  id         String       @id @default(cuid())
  telegramId String?      @unique
  // Telegram client language_code (e.g. 'ru', 'en') captured from updates
  telegramLanguageCode String?
  uuid       String       @unique
  status     VpnUserStatus @default(ACTIVE)
  expiresAt  DateTime?
  createdAt  DateTime     @default(now())

  // default "User" is set at DB level too
  name       String       @default("User")

  // panel integration
  panelEmail String?      @unique

  // legacy pricing visibility (existing user marker)
  firstPaidAt DateTime?

  // напоминание об истечении: когда отправлено (чтобы не слать повторно до продления)
  expiryReminderSentAt DateTime?

  // когда пользователь последний раз был онлайн (обновляется фоновой задачей)
  lastOnlineAt DateTime?

  // server selection (nullable since multi-server support)
  serverId   String?
  server     VpnServer?   @relation(fields: [serverId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  // relations
  subscriptions   Subscription[]
  payments        Payment[]
  paymentIntents  PaymentIntent[]
  userServers     UserServer[]
  supportMessages SupportMessage[]
  browserLoginSessions BrowserLoginSession[]

  @@index([serverId])
  @@index([telegramLanguageCode])
  @@map("vpn_users")
}

model UserServer {
  id        String   @id @default(cuid())
  vpnUserId String
  serverId  String
  panelEmail String  @unique
  active    Boolean  @default(true)
  createdAt DateTime @default(now())

  // which server is currently active for user (in mini-app / bot)
  isActive  Boolean  @default(false)

  vpnUser   VpnUser  @relation(fields: [vpnUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  server    VpnServer @relation(fields: [serverId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([vpnUserId, serverId])
  @@index([vpnUserId])
  @@index([serverId])
  @@map("user_servers")
}

model Subscription {
  id        String   @id @default(cuid())
  vpnUserId String
  periodDays Int
  startsAt  DateTime
  endsAt    DateTime
  active    Boolean  @default(true)

  paymentId String?  @unique

  vpnUser   VpnUser  @relation(fields: [vpnUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([vpnUserId])
  @@index([paymentId])
  @@map("subscriptions")
}

model Payment {
  id                String        @id @default(cuid())
  vpnUserId          String
  amount            Int
  currency          String
  status            PaymentStatus @default(PAID)
  createdAt         DateTime      @default(now())

  paymentIntentId   String?
  planId            String?
  planPriceAtPurchase Int?

  vpnUser           VpnUser       @relation(fields: [vpnUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  plan              Plan?         @relation(fields: [planId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  paymentIntent     PaymentIntent? @relation(fields: [paymentIntentId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  subscription      Subscription?

  @@index([vpnUserId])
  @@index([planId])
  @@index([paymentIntentId])
  @@map("payments")
}

model PaymentIntent {
  id          String              @id @default(cuid())
  vpnUserId   String
  planId      String
  variantId   String
  provider    PaymentProvider
  amount      Int
  currency    String
  status      PaymentIntentStatus @default(PENDING)

  // Provider-specific external reference (transactionId / etc)
  externalId  String?

  // UX fields
  checkoutUrl String?
  invoiceLink String?

  // Signed metadata for mapping callbacks to our domain (optional)
  payload     String?

  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  expiresAt   DateTime?

  vpnUser     VpnUser             @relation(fields: [vpnUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  plan        Plan                @relation(fields: [planId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  payments    Payment[]

  @@index([vpnUserId])
  @@index([planId])
  @@index([status, expiresAt])
  @@unique([provider, externalId])
  @@map("payment_intents")
}

model Plan {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  description String?
  periodDays  Int
  isTrial     Boolean  @default(false)
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())

  availableFor String  @default("ALL")

  // UI
  isTop        Boolean @default(false)

  variants     PlanVariant[]
  payments     Payment[]
  paymentIntents PaymentIntent[]

  @@map("plans")
}

model PlanVariant {
  id        String   @id @default(cuid())
  planId    String

  /// Уникальный код варианта (сохраняем текущие 1m / 1m_stars и т.п.)
  code      String   @unique

  currency  String
  price     Int

  /// Ключ провайдера оплаты (например TELEGRAM_STARS / EXTERNAL_URL).
  provider  String

  active    Boolean  @default(true)
  createdAt DateTime @default(now())

  plan      Plan     @relation(fields: [planId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([planId, currency])
  @@index([planId])
  @@map("plan_variants")
}

model SupportMessage {
  id        String            @id @default(cuid())
  vpnUserId String
  type      SupportMessageType
  message   String
  status    SupportTicketStatus @default(OPEN)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  vpnUser   VpnUser           @relation(fields: [vpnUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([vpnUserId])
  @@index([status])
  @@map("support_messages")
}

model BotConfig {
  id        String   @id @default(cuid())
  tokenEnc  String
  active    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  useMiniApp Boolean @default(false)

  // Payments visibility/availability (bot + mini app)
  paymentsStarsEnabled  Boolean  @default(true)
  paymentsPlategaEnabled Boolean @default(true)
  // Allowed Telegram languages (e.g. ["ru"]) for showing/external payments.
  paymentsPlategaAllowedLangs String[] @default(["ru"])

  // CryptoCloud (encrypted)
  cryptocloudApiKeyEnc    String?
  cryptocloudShopId       String?
  cryptocloudSecretKeyEnc String?

  // Platega (encrypted)
  plategaMerchantIdEnc    String?
  plategaSecretEnc        String?
  plategaPaymentMethod    Int?
  plategaReturnUrl        String?
  plategaFailedUrl        String?

  // Контакты
  publicSiteUrl           String?
  publicSupportTelegram   String?
  publicSupportEmail      String?
  publicCompanyName       String?

  // Лимиты
  panelClientLimitIp      Int?

  // Mini App
  telegramMiniAppUrl      String?

  paymentMethods BotPaymentMethod[]

  @@map("bot_config")
}

model BotPaymentMethod {
  id          String   @id @default(cuid())
  botConfigId String
  // Provider key (e.g. TELEGRAM_STARS, PLATEGA).
  key         String
  enabled     Boolean  @default(true)
  // Allowed Telegram languages (['ru','en','uk']); empty => all languages.
  allowedLangs String[] @default([])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  botConfig   BotConfig @relation(fields: [botConfigId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([botConfigId, key])
  @@index([botConfigId])
  @@map("bot_payment_methods")
}

model BrowserLoginSession {
  id         String           @id @default(cuid())
  code       String           @unique
  status     BrowserLoginStatus @default(PENDING)

  telegramId String?
  vpnUserId  String?
  approvedAt DateTime?

  createdAt  DateTime @default(now())
  expiresAt  DateTime

  vpnUser    VpnUser? @relation(fields: [vpnUserId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([status, expiresAt])
  @@index([telegramId])
  @@index([vpnUserId])
  @@map("browser_login_sessions")
}

